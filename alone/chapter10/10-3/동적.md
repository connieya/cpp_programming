# 동적 메모리 할당

## 할당의 필요성

프로그램이 실행되기 위해서 메모리가 필요하다. 실행 파일 자체도 메모리에 로드되어야 하고
선언된 변수도 메모리에 할당되어야 한다. 예를 들어 정수형 변수와 실수형 변수를 사용할 때 
컴파일러는 해당 변수의 타입 크기만큼 메모리를 할당한다. 정수는 메모리에 4바이트, 실수는 메모리에
8바이트가 할당된다. 이렇게 프로그램을 작성할 때 미리 메모리에 필요한 양을 알려주는 할당을
정적 할당(Static Allocation)이라고 한다. 

```c++
int num;
scanf("%d",&num);
int score[num];
```

위의 코드는 잘못된 코드이다.
배열의 크기에는 변수가 올 수없고 상수만 올 수 있다.
컴파일러 입장에서는 저 변수의 값이 얼마가 될지 모르기 때문이다.

즉 정적 할당시 필요한 배열의 크기를 변수로 지정할 수 없다.

메모리 필요량을 프로그램 작성 중에 결정할 수 없을 때는 정적 할당 할수 없고 동적 할당을 사용해야 한다.

```c++
char *buf = 동적할당(파일크기만큼)
buf에 파일 읽음
원하는 작업 - buf에 문자열이 있는지 조사
buf 해제        
```

동적 할당은 필요할 때 필요한 만큼만 메모리를 할당해 사용하고 다 쓰면 버리는 것이다.

동적 할당된 메모리는 이름이 없는 변수라고 할 수 있다.
독점적인 메묘리 영역을 차지하고 있으므로 일단 값을 기억할 수 있지만 이름이 없으므로 오로지 포인터로만
접근할 수 있다. 그래서 malloc 함수가 리턴하는 포인터는 반드시 적절한 타입의 포인터 변수로 대입받아야 한다.
시작 번지를 잃어버리면 할당된 메모리를 쓸 수 없음은 물론이고 다 사용하고 난 후에 해제하지도 못한다.

## 메모리 관리 원칙

메모리의 실체는 시스템에 장착되어 있는 RAM이다.

복수 개의 프로그램이 꼭 필요한 만큼의 메모리를 충돌없이 사이좋게 잘 사용하려면 정교한 메모리 관리
원칙이 필요하다. 

메모리 관리는 응용 프로그램이 할 수 없으며 운영체제가 직접 하는데 하드웨어 관리, 스케줄링 등과 함께
운영체제의 주요 임무 중 하나이다. 다음은 운영체제가 메모리를 관리하는 일반적인 원칙이다.

1. 메모리 관리의 주체는 운영체제이다. 응용 프로그램은 직접 메모리를 관리할 수 없으며 메모리가 필요할 경우
운영 체제에게 할당 요청을 해야 한다. 16비트 운영체제에서는 응용 프로그램이 임의의 주소 공간을 액세스할 수 있었지만
32비트의 보호된 운영체제들은 안전성을 높이기 위해 응용 프로그램이 임으의 메모리를 액세스하는 것을 금지하고 있다.
반드시 운영체제를 통해서만 메모리를 할당받을 수 있다.
2. 운영체제는 메모리가 있는 한 할당 요청을 거절하지 않는다. 메모리라는 것은 결국 작업을 위해 존재하는 것이므로
응용 프로그램(= 이 프로그램을 쓰는 사용자)이 달라고 하는 만큼 내 주도록 되어있다. 만약 요청한 양만큼 메모리가 남아
있지 않을 경우는 에러를 리턴하여 응용 프로그램에게 메모리가 없다는 것을 알려준다. 최근의 운영체제들은
요청한 만큼 메모리가 남아 있지 않을 경우 가상 메모리 공간을 늘려서라도 필요한 메모리를 만들어 줄 정도로 친절하다.
3. 한 번 할당된 메모리 공간은 절대로 다른 목적을 위핼 재할당 되지 않는다. 운영체제는 메모리 공간을 누가 얼마만큼
사용하고 있는지 모두 기억하고 있으며 반납하기 전에는 응용 프로그램이 이 공간을 독점적으로 사용할 수 있도록 보장한다.
그래서 한 번 할당한 메모리는 일부러 해제하지 않는 한은 언제까지든 안심하고 사용할 수 있다.
4. 응용 프로그램이 할당된 메모리르 해제하면 운영체제는 이 공간을 빈 영역으로 인식하고 다른 목적을 위해
사용할 수 있도록 한다. 즉, 특정 메모리 공간을 동시에 두 프로그램이 사용할 수는 없지만 순서대로 번갈아가면서
사용하는 것은 가능하다. 메모리 공간이 무한하지 않기 때문에 응용 프로그램들은 자신이 꼭 필요한 만큼만 할당해서
다 쓴 후에는 반드시 반납해서 다른 목적에 사용될 수 있도록 해야 한다.

## 할당 및 해제

void *malloc(size_t size);
void free(void *memblock);

malloc 함수 => 인수로 필요한 만큼의 메모리양을 전달하면 요청한 만큼 할당한다.

실행 중에 할당하는 것이기 때문에 malloc(num)  처럼 변수를 사용할 수 있다.
운영체제는 사용되지 않는 빈 영역(힙)에서 요청 받은 만큼 메모리르 할당 해준다.
이때 메모리가 시작되는 번지를 리턴해준다. 

응용 프로그램은 할당 받은 메모리를 어떤 타입으로 사용할지 모르기 때문에
void * 로 받은 뒤 사용하는 쪽에서 원하는 타입으로 캐스팅해야 한다.

할당된 메모리를 해제하지 않았을 때의 문제점은
메모리 관리 원칙상 이 메모리는 시스템을 재부팅하기 전에는 다른 응용 프로그램이 사용하지 못한다.
그래서 16비트 환경에서 해제를 하지 않으면 시스템 메모리가 감소되며 할당된 채로
남아 있는 영역에 의해 메모리가 조각난다.이렇게 되면 다음 프로그램이 실행될 충분히 큰 공간이 없어
시스템 다운으로 이어지기도 한다. 그러나 32비트 운영체제는 메모리를 할당한 프로그램이 종료되면
해제하지 않은 메모리를 알아서 회수하도록 되어 있으므로 16비트에서처럼 큰 문제가 되지는 않는다.
그렇다고 해서 할당만  해 놓고 해제하지 않는 것이 좋다거나 그래도 괜찮다는 에기는 절대로 아니다.


## 재할당

void *calloc(size_t num , size_t size);

malloc 함수와 마찬가지로 메모리를 할당하되 필요한 메모리양을 지정하는 방법만 다르다.

첫 번째 인수 num은 할당할 요소의 개수이고, size 는 요소의 크기이다. 
malloc은 필요한 메모리를 바이트 단위 하나로 전달 받지만 calloc은 두 개의 값으로 나누어 전달받는 점이
다르다. malloc이 "몇 바이트 할당 해주세요"라고 요청하는 것에 비해 calloc 은 "몇 바이트짜리 몇 개 할당 해주세요"
라고 요청하는 것이다. 그래서 다음 두 호출문은 동일하다.

- ar = (int *) malloc(10*sizeof(int));
- ar = (int *) calloc(10, sizeof(int));

calloc 이 malloc과 또 다른 차이점은 메모리 할당 후 전부 0으로 초기화 한다는 것이다.
malloc은 메모리 할당만 하므로 할당된 메모리에는 쓰레기 값이 들어 있지만 calloc으로 할당하면 할당 후
모든 메모리를 0으로 채운다.

동적 할당이 필요한 이유는 컴파일할 시점에 필요한 메모리양을 모를 때가 있기 때문이다.
재할당이 필요한 이유는 실행 중에라도 필요한 메모리양을 가늠할 수 없을 때가 있기 때문이다.

예를 들어
네트워크를 통해 파일을 전송하는 프로그램을 작성한다고 해보자. 네트워크의 반대편에서 보내는 파일을
받아야 하는데 이 파일의 크기는 다 받아 보기 전에는 알 수 없는 상황이다.
이럴 때는 최초 적당한 크기로 버퍼를 할당한다. 가렬 1M 정도만 할당한 채로 네트워크로 들어오는 패킷을
이 버퍼에 누적시킨다. 그러다가 받은 패킷 총량이 1M가 되면 다시 1M 더 늘려 2M로 재할당한다.
이런 식으로 패킷을 다 받을때 까지 계속 재할당하면 된다.