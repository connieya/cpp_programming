# void형 포인터

## void 형

대상체의 타입을 명시하지 않는 특별한 포인터형 이 바로 void형 포인터
void형은 함수와 포인터 변수에게만 적용되는 타입이므로 일반 변수에는 쓸 수 없다.

###  void 형의 특징
- 임의의 대상체를 가리킬 수 있다.

대상체가 정해져 있지 않다는 말이 어떤 대상체도 가리키지 못한다는 뜻이 아니라 
임의의 대상체를 가리킬 수 있다는 말이다.

void형 포인터는 쉽게 말해서 임의의 대상체에 대한 포인터 형이다.
정수든 실수든 가리지 않고 메모리의 위치를 기억할 수 있다.

- *연산자를 쓸 수 없다.

*연산자로 포인터가 가리키는 메모리의 값을 읽을 수 없다. 대상체의 타입이 정해져 있지 않으므로
포인터가 가리키는 위치에서 몇 바이트를 읽어야 할지 또 읽어낸 비트를 어떤식으로 해석해야 할지를 모르기 때문이다.
```c++
#include "stdio.h"

int main(void)
{
    int i = 1234;
    void *vp;

    vp = &i;
    printf("%d\n",vp);
//    printf("%d\n",*vp); // 'void*' is not a pointer-to-object type
    printf("%d\n",*(int *)vp); // (int *)  <-  정수형 포인터로 바꾸는 작업 , 
    // 그리고 제일 앞에 *  <- 포인터가 가리키는 번지에 들어있는 값을 참조
}
```

- 증감 연산자를 쓸 수 없다.

대상체의 타입이 정해져 있지 않으므로 당연히 증감 연산자도 사용할 수 없다.
증감 연산자를 사용한 듯 , 얼만큼 더하고 뺄지는 대상체가 없기 때문에 애매하기 때문이다.
즉, 대상체의 크기를 모르기 때문에 얼마만큼 이동해야 할지 모른다.

```c++
#include "stdio.h"

int main(void)
{
    int ar[] = {1,2,3,4,5};
    void *vp;
    vp = ar;
//    vp = vp+1; // 에러 발생 +1을 해도 몇 바이트 뒤로 이동할지 모른다.
    printf("%d\n",vp);
    printf("%d\n",*(int*)vp);
    vp = (int*)vp+1; //  정수형 포인터 캐스팅을 했기 때문에 그 뒤에 +1을 하면 4바이트씩 이동해야 한다는 것을 알게된다.
    printf("%d\n",*(int*)vp);
    printf("%d\n",&ar[0]);
}
```

void형 포인터는 대상체가 정해져 있지 않으므로 임의의 번지를 저장할 수 있지만
대상체가 정해져 있지 않기 때문에 *연산자로 값을 읽거나 증감 연산자로 이동할 때는 반드시 캐스트 연산자가
필요하다. 값을 읽거나 전후 위치로 이동하는 기능을 빼고 순수하게 메모리의 한 지점을 가리키는 기능만 가지는
포인터라고 할 수 있다. 

### void 형 포인터의 활용

포인터로 접급해야할 대상체가 분명히 정해져 있으면 그에 해당하는 타입의 포인터 변수를 사용하면 되는데,
대상체를 미리 결정하지 않고 임의의 대상체에 대해 값을 초기화 한 뒤 동작하게 하고 싶을 때가 있다.
대표적으로 메모리를 특정한 값으로 채우는 memset 함수를 보자.

void *memset(void*s, int c , size_t n);

이 함수의 첫번째 인자를 보면 void 포인터 변수이기 때문에 , 어떤 타입의 포인터를 인자로 받을 수 있다.
```c++
#include "stdio.h"

void arDump(void *array , int length);

int main(void)
{
    int ari[] = {1,2,3,4,5};
    char arc[] = "Pointer";

    arDump(ari, sizeof(ari));
    arDump(arc, sizeof(arc));
}

void arDump(void *array , int length) {
    int i;
    for (i=0; i<length; i++) {
        printf("%02X ",*((unsigned char *)array+i));
    }
    printf("\n");
}
```

### NULL 포인터
NULL 포인터는 0으로 정의되어 있는 포인터 상수값이다.

어떤 포인터가  NULL값을 가지고 있으면 그것은 메모리의 0번지를 참조하고 있다는 말이다.
0번지는 메모리의 제일 처음 공간을 나타내며, 대부분 플랫폼에서는 이 위치가
ROM이나 시스템 예약영역에 해당된다.

포인터를 리턴하는 함수는 에러가 발생했을 때 대부분 NULL 값을 리턴한다.

strchr 함수를 예로 들어보면 strchr 함수는 문자열에서 특정 문자의 번지를 리턴하는 함수인데
만약 해당 문자가 없으면 NULL을 리턴하는데, 이때는 문자열에 해당 문자가 없다는 뜻이지 
이 문자가 0번지에 위치해있다는 뜻이 아니다. 

```c++
#include "stdio.h"
#include "cstring"
int main(void)
{
    char str[] = "korea";
    char *p;
    p = strchr(str,'r');
    puts(p); // rea
    printf("%d\n",p); // 6422296
    printf("%d\n",&str[2]); // 6422296;
    if (p != NULL) {
        *p = 's';
    }
    puts(str); // kosea
}
```

NULL 점검을 하지 않고 'r'을 's'로 바꾸려고 한다면 0번지를 잘못 건드리는 오동작을 할 가능성이 있다.